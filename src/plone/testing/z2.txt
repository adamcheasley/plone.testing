Zope 2 layers
-------------

The Zope 2 layers are found in the module ``plone.testing.z2``:

    >>> from plone.testing import z2

For testing, we need a testrunner

    >>> from zope.testing.testrunner import runner

Startup
~~~~~~~

``STARTUP`` is the base layer for all Zope 2 testing. It sets up a Zope 2
sandbox environment that is suitable for testing. It does not have any
bases.

**Note**: You should probably use at least ``BASIC_SITE`` for any real test.
    
    >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)
    'plone.testing.z2.Startup'

    >>> z2.STARTUP.__bases__
    ()

On layer setup, Zope is initialised using a lightweight process. This involves
certain patches to global modules that Zope manages, to reduce setup time,
a database based on ``DemoStorage``, and a minimal set of products that must
be installed for Zope 2 to work. A minimal set of ZCML is loaded, but packages
in the ``Products`` namespace are not automatically configured.

Let's just verify that we have an empty component registry before the test:

    >>> from zope.component import getSiteManager
    >>> list(getSiteManager().registeredAdapters())
    []

    >>> options = runner.get_options([], [])
    >>> setupLayers = {}
    >>> runner.setup_layer(options, z2.STARTUP, setupLayers)
    Set up plone.testing.z2.Startup in ... seconds.

After layer setup, the ``zodbDB`` resource is available, pointing to the
default ZODB.

    >>> z2.STARTUP['zodbDB']
    <ZODB.DB.DB object at ...>
    
    >>> z2.STARTUP['zodbDB'].storage
    DemoStorage('MappingStorage', 'MappingStorage')

In addition, the resources ``host`` and ``port`` are set to the default
hostname and port that are used for URLs generated from Zope. These are
hardcoded, but shadowed by layers that provide actual running Zope
instances.

    >>> z2.STARTUP['host']
    'nohost'
    >>> z2.STARTUP['port']
    80

At this point, it is also possible to get hold of a Zope application root.
If you are setting up a layer fixture, you can obtain an application root
with the correct database that is properly closed by using the ``zopeApp()``
context manager.

    >>> with z2.zopeApp() as app:
    ...     print app.objectIds()
    ['acl_users', 'Control_Panel']
    
Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in
a ``testSetUp()`` or ``testTearDown()`` method. The ``BASIC_SITE`` and
``FUNCTIONAL`` layers manage the application object for you, exposing them as
the resource ``app`` - see below.

After layer setup, the global component registry contains a number of
components needed by Zope.

    >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot
    True

To load additional ZCML, you can use the ``configurationContext`` resource:

    >>> z2.STARTUP['configurationContext']
    <zope.configuration.config.ConfigurationMachine object at ...>

See ``zca.txt`` for details about how to use ``zope.configuration`` for this
purpose.

The ``STARTUP`` layer does not perform any specific test setup or tear-down.
That is left up to the ``BASIC_SITE`` and ``FUNCTIONAL`` layers.

    >>> z2.STARTUP.testSetUp()
    >>> z2.STARTUP.testTearDown()

Layer tear-down resets the environment.

    >>> runner.tear_down_unneeded(options, [], setupLayers)
    Tear down plone.testing.z2.Startup in ... seconds.

    >>> import Zope2
    >>> Zope2._began_startup
    0
    >>> Zope2.DB is None
    True
    >>> Zope2.bobo_application is None
    True

    >>> list(getSiteManager().registeredAdapters())
    []

Basic site
~~~~~~~~~~

``BASIC_SITE`` is intended for Zope 2 integration testing. It extends
``STARTUP``, adding a minimal test fixture to the database: A folder is
created with its own user folder, which in turn has a user and a custom role.
A transaction is begun before and rolled back after each test. Two resources,
``app`` and ``folder``, are available during testing as well, and should be
used for all access to persistent Zope objects.
    
    >>> "%s.%s" % (z2.BASIC_SITE.__module__, z2.BASIC_SITE.__name__,)
    'plone.testing.z2.BasicSite'

    >>> z2.BASIC_SITE.__bases__
    (<Layer 'plone.testing.z2.Startup'>,)

    >>> options = runner.get_options([], [])
    >>> setupLayers = {}
    >>> runner.setup_layer(options, z2.BASIC_SITE, setupLayers)
    Set up plone.testing.z2.Startup in ... seconds.
    Set up plone.testing.z2.BasicSite in ... seconds.

After layer setup, the ``zodbDB`` resource from the ``STARTUP`` layer is
shadowed with a database instance that uses a stacked ``DemoStorage``. This
keeps the persistent aspects of the test fixture separate from the underlying
ZODB from the ``STARTUP`` layer.

    >>> z2.BASIC_SITE['zodbDB']
    <ZODB.DB.DB object at ...>
    
    >>> z2.BASIC_SITE['zodbDB'].storage
    DemoStorage("DemoStorage('MappingStorage', 'MappingStorage')", 'MappingStorage')
    
    **Hint:** If you base a layer on ``BASIC_SITE`` and want to set up your
    own persistent fixture, you can follow the same pattern that
    ``BASIC_SITE`` uses to add a fixture on top of ``STARTUP``:

        def setUp(self):
        
            from ZODB.DemoStorage import DemoStorage
            from ZODB.DB import DB
        
            # Stack a new DemoStorage on top of the one from the base layer.
            storage = DemoStorage(base=self['zodbDB'].storage)
            self['zodbDB'] = DB(storage)
            
            with zopeApp() as app:
                # do something with app here
                # it will use the new database
        
        def tearDown(self):
            # Zap all changes to the stacked demo storage and let the next
            # layer start afresh
            self['zodbDB'].close()
            del self['zodbDB']
    
    The ``zopeApp()`` context manager returns a request-wrapped app object,
    making sure it is properly closed after the ``with`` block, and that the
    transaction is committed if there if no error.
    
    Note that you should **not** use this in a test, because the test setup
    will take care of managing the connections for you. Use the ``app``
    resource instead.

The application root now contains a test folder. Several constants in the
``z2`` module define various aspects of the test fixture:

    >>> z2.TEST_FOLDER_NAME
    'test_folder_1_'
    
    >>> z2.TEST_USER_NAME
    'test_user_1_'
    
    >>> z2.TEST_USER_PASSWORD
    'secret'
    
    >>> z2.TEST_USER_ROLE
    'test_role_1_'
    
    >>> z2.TEST_USER_PERMISSIONS
    ['Access contents information', 'View']

We can see this in the fixture:

    >>> with z2.zopeApp() as app:
    ...     print app.objectIds()
    ...     folder = app[z2.TEST_FOLDER_NAME]
    ...     print folder.objectIds()
    ...     user = folder['acl_users'].getUserById(z2.TEST_USER_NAME)
    ...     print user.getId()
    ...     print user.getRolesInContext(app[z2.TEST_FOLDER_NAME])
    ...     print [p['name'] for p in folder.permissionsOfRole(z2.TEST_USER_ROLE) if p['selected']]
    ['acl_users', 'Control_Panel', 'test_folder_1_']
    ['acl_users']
    test_user_1_
    ['test_role_1_', 'Authenticated']
    ['Access contents information', 'View']

Let's now simulate a test. On test setup, the ``app`` resource is made
available. In a test, you should always use this to access the application
root. The ``folder`` resource can also be used to access the test folder.

    >>> z2.STARTUP.testSetUp()
    >>> z2.BASIC_SITE.testSetUp()

The test may now inspect and modify the environment.

    >>> folder = z2.BASIC_SITE['folder'] # would normally be self.layer['folder']
    >>> folder.manage_addFolder('subfolder')
    >>> folder.objectIds()
    ['acl_users', 'subfolder']
    
    >>> z2.BASIC_SITE['app'].objectIds() # would normally be self.layer['app']
    ['acl_users', 'Control_Panel', 'test_folder_1_']
    
During the test, we are "logged" in as the test user.

    >>> from AccessControl import getSecurityManager
    >>> getSecurityManager().getUser()
    <User 'test_user_1_'>
    
It is possible to create and log in as another user. The latter is achieved
using the ``z2.login()`` helper.

    >>> folder['acl_users'].userFolderAddUser('test_user_2_', 'secret', [z2.TEST_USER_ROLE], [])
    >>> z2.login(folder['acl_users'], 'test_user_2_')
    
    >>> getSecurityManager().getUser()
    <User 'test_user_2_'>
    
    >>> getSecurityManager().getUser().getRolesInContext(folder)
    ['test_role_1_', 'Authenticated']
    
We can also change the roles using the ``z2.setRoles()`` helper:

    >>> z2.setRoles(folder['acl_users'], 'test_user_2_', [])
    >>> getSecurityManager().getUser().getRolesInContext(folder)
    ['Authenticated']
    
    >>> z2.setRoles(folder['acl_users'], 'test_user_2_', [z2.TEST_USER_ROLE])
    >>> getSecurityManager().getUser().getRolesInContext(folder)
    ['test_role_1_', 'Authenticated']

You can test as the anonymous user by using ``z2.logout()``:

    >>> z2.logout()
    >>> getSecurityManager().getUser()
    <SpecialUser 'Anonymous User'>

On tear-down, the transaction is rolled back:

    >>> z2.BASIC_SITE.testTearDown()
    >>> z2.STARTUP.testTearDown()

    >>> 'app' in z2.BASIC_SITE
    False
    
    >>> 'folder' in z2.BASIC_SITE
    False
    
    >>> with z2.zopeApp() as app:
    ...     print app.objectIds()
    ...     print app[z2.TEST_FOLDER_NAME].objectIds()
    ['acl_users', 'Control_Panel', 'test_folder_1_']
    ['acl_users']
    
When the ``BASIC_SITE`` layer is torn down, the persistent fixture is removed,
but the original database remains.

    >>> runner.tear_down_unneeded(options, [z2.STARTUP], setupLayers)
    Tear down plone.testing.z2.BasicSite in ... seconds.

    >>> with z2.zopeApp() as app:
    ...     app.objectIds()
    ['acl_users', 'Control_Panel']
    
We can tear that down too:

    >>> runner.tear_down_unneeded(options, [], setupLayers)
    Tear down plone.testing.z2.Startup in ... seconds.

Functional testing
~~~~~~~~~~~~~~~~~~

The ``FUNCTIONAL`` layer is very similar to ``BASIC_SITE``, and exposes
the same fixture and resources. However, it has different transaction
semantics. ``BASIC_SITE`` creates a single database storage, and rolls back
the transaction after each test. ``FUNCTIONAL`` creates a whole new database
storage (stacked on top of the basic fixture) for each test. This allows
testing of code that performs an explicit commit, which is usually required
for end-to-end testing. The downside is that the set-up and tear-down of each 
test takes longer.

Like ``BASIC_SITE``, ``FUNCTIONAL`` is based on ``STARTUP``.
    
    >>> "%s.%s" % (z2.FUNCTIONAL.__module__, z2.FUNCTIONAL.__name__,)
    'plone.testing.z2.Functional'

    >>> z2.FUNCTIONAL.__bases__
    (<Layer 'plone.testing.z2.Startup'>,)

    >>> options = runner.get_options([], [])
    >>> setupLayers = {}
    >>> runner.setup_layer(options, z2.FUNCTIONAL, setupLayers)
    Set up plone.testing.z2.Startup in ... seconds.
    Set up plone.testing.z2.Functional in ... seconds.

After layer setup, the ``zodbDB`` resource from the ``STARTUP`` layer is
shadowed with a database instance that uses a stacked ``DemoStorage``. This
keeps the persistent aspects of the test fixture separate from the underlying
Zope object.

    >>> z2.FUNCTIONAL['zodbDB']
    <ZODB.DB.DB object at ...>
    
    >>> z2.FUNCTIONAL['zodbDB'].storage
    DemoStorage("DemoStorage('MappingStorage', 'MappingStorage')", 'MappingStorage')
    
    **Hint:** You can use the ``z2.zopeApp()`` context manager for test setup
    in your own layer based on ``FUNCTIONAL`` - see above.

The test fixture is the same as the ``BASIC_SITE`` one.

    >>> with z2.zopeApp() as app:
    ...     print app.objectIds()
    ...     folder = app[z2.TEST_FOLDER_NAME]
    ...     print folder.objectIds()
    ...     user = folder['acl_users'].getUserById(z2.TEST_USER_NAME)
    ...     print user.getId()
    ...     print user.getRolesInContext(app[z2.TEST_FOLDER_NAME])
    ...     print [p['name'] for p in folder.permissionsOfRole(z2.TEST_USER_ROLE) if p['selected']]
    ['acl_users', 'Control_Panel', 'test_folder_1_']
    ['acl_users']
    test_user_1_
    ['test_role_1_', 'Authenticated']
    ['Access contents information', 'View']
    
Let's now simulate a test. On test setup, the ``app`` resource is made
available. In a test, you should always use this to access the application
root. The ``folder`` resource can also be used to access the test folder.

    >>> z2.STARTUP.testSetUp()
    >>> z2.FUNCTIONAL.testSetUp()

The test may now inspect and modify the environment. It may also
commit things.

    >>> folder = z2.FUNCTIONAL['folder'] # would normally be self.layer['folder']
    >>> folder.manage_addFolder('subfolder')
    >>> folder.objectIds()
    ['acl_users', 'subfolder']
    
    >>> z2.FUNCTIONAL['app'].objectIds() # would normally be self.layer['app']
    ['acl_users', 'Control_Panel', 'test_folder_1_']
    
    >>> import transaction
    >>> transaction.commit()
    
On tear-down, the database is torn down.

    >>> z2.FUNCTIONAL.testTearDown()
    >>> z2.STARTUP.testTearDown()

    >>> 'app' in z2.FUNCTIONAL
    False
    
    >>> 'folder' in z2.FUNCTIONAL
    False
    
    >>> with z2.zopeApp() as app:
    ...     print app.objectIds()
    ...     print app[z2.TEST_FOLDER_NAME].objectIds()
    ['acl_users', 'Control_Panel', 'test_folder_1_']
    ['acl_users']
    
When the ``FUNCTIONAL`` layer is torn down, the persistent fixture is removed,
but the original database remains.

    >>> runner.tear_down_unneeded(options, [z2.STARTUP], setupLayers)
    Tear down plone.testing.z2.Functional in ... seconds.

    >>> with z2.zopeApp() as app:
    ...     app.objectIds()
    ['acl_users', 'Control_Panel']
    
We can tear that down too:

    >>> runner.tear_down_unneeded(options, [], setupLayers)
    Tear down plone.testing.z2.Startup in ... seconds.

HTTP server
~~~~~~~~~~~

The ``ZSERVER`` layer extends ``FUNCTIONAL`` to start up a single-threaded
Zope server in a separate thread. This makes it possible to connect to the
test instance using a web browser or a testing tool like Selenium or Windmill.

    >>> "%s.%s" % (z2.ZSERVER.__module__, z2.ZSERVER.__name__,)
    'plone.testing.z2.ZServer'

    >>> z2.ZSERVER.__bases__
    (<Layer 'plone.testing.z2.Functional'>,)

    >>> options = runner.get_options([], [])
    >>> setupLayers = {}
    >>> runner.setup_layer(options, z2.ZSERVER, setupLayers)
    Set up plone.testing.z2.Startup in ... seconds.
    Set up plone.testing.z2.Functional in ... seconds.
    Set up plone.testing.z2.ZServer in ... seconds.

After layer setup, the resources ``host`` and ``port`` are available, and
indicate where Zope is running.

    >>> host = z2.ZSERVER['host']
    >>> host
    'localhost'
    
    >>> port = z2.ZSERVER['port']
    >>> port
    55001
    
Let's now simulate a test. Test setup does nothing beyond what the base layers
do.

    >>> z2.STARTUP.testSetUp()
    >>> z2.FUNCTIONAL.testSetUp()
    >>> z2.ZSERVER.testSetUp()
    
It is common in a test to use the Python API to change the state of the server
(e.g. create some content or change a setting) and then use the HTTP protocol
to look at the results. Bear in mind that the server is running in a separate
thread, with a separate security manager, so calls to ``z2.login()`` and
``z2.logout()``, for instance, do not affect the server thread.
    
    >>> folder = z2.ZSERVER['folder'] # would normally be self.layer['folder']
    >>> folder.manage_addFolder('subfolder')

Note that we need to commit the transaction before it will show up in the
other thread.

    >>> import transaction; transaction.commit()

We can now look for this new object through the server.

    >>> folder_url = folder.absolute_url()
    >>> folder_url
    'http://localhost:55001/test_folder_1_'
    
    >>> import urllib2
    >>> conn = urllib2.urlopen(folder_url + '/subfolder', timeout=5)
    >>> print conn.read()
    <Folder at subfolder>
    >>> conn.close()

Test tear-down does nothing beyond what the base layers do.

    >>> z2.ZSERVER.testTearDown()
    >>> z2.FUNCTIONAL.testTearDown()
    >>> z2.STARTUP.testTearDown()

When the server is torn down, the ZServer thread is stopped.

    >>> runner.tear_down_unneeded(options, [], setupLayers)
    Tear down plone.testing.z2.ZServer in ... seconds.
    Tear down plone.testing.z2.Functional in ... seconds.
    Tear down plone.testing.z2.Startup in ... seconds.

    >>> conn = urllib2.urlopen(folder_url + '/subfolder', timeout=5)
    Traceback (most recent call last):
    ...
    URLError: <urlopen error [Errno 61] Connection refused>

FTP server
~~~~~~~~~~

The ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it
starts an FTP server instead of an HTTP server.

    **Warning:** It is generally not safe to run the ``ZSERVER`` and
    ``FTP_SERVER`` layers concurrently, because they both start up the same
    ``asyncore`` loop. If you need concurrent HTTP and FTP servers in a test,
    you can create your own layer by subclassing the ``ZServer`` layer class,
    and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set
    up and close both servers. See the code for an example.

The ``FTP_SERVER`` layer is based on the ``FUNCTIONAL`` layer.

    >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)
    'plone.testing.z2.FTPServer'

    >>> z2.FTP_SERVER.__bases__
    (<Layer 'plone.testing.z2.Functional'>,)

    >>> options = runner.get_options([], [])
    >>> setupLayers = {}
    >>> runner.setup_layer(options, z2.FTP_SERVER, setupLayers)
    Set up plone.testing.z2.Startup in ... seconds.
    Set up plone.testing.z2.Functional in ... seconds.
    Set up plone.testing.z2.FTPServer in ... seconds.

After layer setup, the resources ``host`` and ``port`` are available, and
indicate where Zope is running.

    >>> host = z2.ZSERVER['host']
    >>> host
    'localhost'
    
    >>> port = z2.ZSERVER['port']
    >>> port
    55002
    
Let's now simulate a test. Test setup does nothing beyond what the base layers
do.

    >>> z2.STARTUP.testSetUp()
    >>> z2.FUNCTIONAL.testSetUp()
    >>> z2.FTP_SERVER.testSetUp()
    
As with ``ZSERVER``, we will set up some content for the test and then access
it over the FTP port.

    >>> folder = z2.FTP_SERVER['folder'] # would normally be self.layer['folder']
    >>> folder.manage_addFolder('subfolder')

We'll also create a user in the root user folder to make FTP access easier.

    >>> app = z2.FTP_SERVER['app'] # would normally be self.layer['app']
    >>> app['acl_users'].userFolderAddUser('admin', 'secret', ['Manager'], ())

Note that we need to commit the transaction before it will show up in the
other thread.

    >>> import transaction; transaction.commit()

We can now look for this new object through the server.

    >>> folder_path = folder.absolute_url_path()
    
    >>> import ftplib
    >>> ftpClient = ftplib.FTP()
    >>> ftpClient.connect(host, port, timeout=5)
    '220 localhost FTP server (...) ready.'
    
    >>> ftpClient.login('admin', 'secret')
    '230 Login successful.'

    >>> ftpClient.cwd(folder_path)
    '250 CWD command successful.'
    
    >>> ftpClient.retrlines('LIST')
    drwxrwx---   1 Zope         Zope        0 ... .
    d---------   1 Zope         Zope        0 ... ..
    --w--w----   1 Zope         Zope        0 ... acl_users
    drwxrwx---   1 test_user_1_ Zope        0 ... subfolder
    '226 Transfer complete'

    >>> ftpClient.quit()
    '221 Goodbye.'
    
Test tear-down does nothing beyond what the base layers do.

    >>> z2.FTP_SERVER.testTearDown()
    >>> z2.FUNCTIONAL.testTearDown()
    >>> z2.STARTUP.testTearDown()

When the server is torn down, the FTP thread is stopped.

    >>> runner.tear_down_unneeded(options, [], setupLayers)
    Tear down plone.testing.z2.FTPServer in ... seconds.
    Tear down plone.testing.z2.Functional in ... seconds.
    Tear down plone.testing.z2.Startup in ... seconds.

    >>> ftpClient.connect(host, port, timeout=5)
    Traceback (most recent call last):
    ...
    error: [Errno 61] Connection refused
