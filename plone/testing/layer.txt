Layer base class
================

This package provides a layer base class which can be used by the test
runner. It is available as a convenience import from the package root.

    >>> from plone.testing import Layer

A layer may be instantiated directly, though in this case the ``name``
argument is required (see below).

    >>> NULL_LAYER = Layer(name="Null layer")

This is not very useful on its own. It has an empty list of bases, and each of
the layer lifecycle methods does nothing.

    >>> NULL_LAYER.__bases__
    ()
    >>> NULL_LAYER.__name__
    'Null layer'
    >>> NULL_LAYER.__module__
    'plone.testing.layer'
    
    >>> NULL_LAYER.setUp()
    >>> NULL_LAYER.testSetUp()
    >>> NULL_LAYER.tearDown()
    >>> NULL_LAYER.testTearDown()

Just about the only reason to use this directly (i.e. not as a base class) is
to group together other layers.

    >>> SIMPLE_LAYER = Layer((NULL_LAYER,), name="Simple layer", module='plone.testing.tests')

Here, we've also set the module name directly. The default for all layers is
to take the module name from the stack frame where the layer was instantiated.
In doctests, that doesn't work, though, so we fall back on the module name of
the layer class. The two are often the same, of course.

This layer now has the bases, name and module we set:

    >>> SIMPLE_LAYER.__bases__
    (<Layer 'plone.testing.layer.Null layer'>,)
    
    >>> SIMPLE_LAYER.__name__
    'Simple layer'
    
    >>> SIMPLE_LAYER.__module__
    'plone.testing.tests'

The ``name`` argument is required when using ``Layer`` directly (but not
when using a subclass):

    >>> Layer((SIMPLE_LAYER,))
    Traceback (most recent call last):
    ...
    ValueError: The "name" argument is required when instantiating `Layer` directly

    >>> class NullLayer(Layer):
    ...     pass
    >>> NullLayer()
    <Layer '__builtin__.NullLayer'>

Using ``Layer`` as a base class
-------------------------------

The usual pattern is to use ``Layer`` as a base class for a custom layer.
This can then override the lifecycle methods as appropriate, as well as
set a default list of bases.

    >>> class BaseLayer(Layer):
    ...
    ...     def setUp(self):
    ...         print "Setting up base layer"
    ...     
    ...     def tearDown(self):
    ...         print "Tearing down base layer"

    >>> BASE_LAYER = BaseLayer()

The layer name and module are taken from the class.

    >>> BASE_LAYER.__bases__
    ()
    >>> BASE_LAYER.__name__
    'BaseLayer'
    >>> BASE_LAYER.__module__
    '__builtin__'

We can now create a new layer that has this one as a base. We'll also set the
default name explicitly here by passing a name to the the super-constructor.
This is mostly cosmetic, but may be desirable if the class name would be
misleading in the test runner output.

    >>> class ChildLayer(Layer):
    ...     __bases__ = (BASE_LAYER,)
    ...     
    ...     def __init__(self, bases=None, name='Child layer', module=None):
    ...         super(ChildLayer, self).__init__(bases, name, module)
    ...     
    ...     def setUp(self):
    ...         print "Setting up child layer"
    ...     
    ...     def tearDown(self):
    ...         print "Tearing down child layer"

    >>> CHILD_LAYER = ChildLayer()

    >>> CHILD_LAYER.__bases__
    (<Layer '__builtin__.BaseLayer'>,)
    >>> CHILD_LAYER.__name__
    'Child layer'
    >>> CHILD_LAYER.__module__
    '__builtin__'

Overriding the default list of bases
------------------------------------

We can override the list of bases on a per-instance basis. This may be
dangerous, i.e. the layer is likely to expect that its bases are set up. 
Sometimes, it may be useful to inject a new base, however, especially when
re-using layers from other packages.

The new list of bases is passed to the constructor. When creating a second
instance of a layer (most layers are global singletons created only once),
it's useful to give the new instance a unique name, too.

    >>> NEW_CHILD_LAYER = ChildLayer((SIMPLE_LAYER, BASE_LAYER,), name='New child')

    >>> NEW_CHILD_LAYER.__bases__
    (<Layer 'plone.testing.tests.Simple layer'>, <Layer '__builtin__.BaseLayer'>)
    >>> NEW_CHILD_LAYER.__name__
    'New child'
    >>> NEW_CHILD_LAYER.__module__
    '__builtin__'

Using the resource manager
--------------------------

Layers are also resource managers. Resources can be set, retrieved and
deleted using dictionary syntax. Resources in base layers are available in
child layers. When an item is set on a child layer, it shadows any items with
the same key in any base layer (until it is deleted), but the original item
still exists and is accessible from the base layer directly.

Let's create a somewhat complex hierarchy of layers that all set resources
under a key ``'foo'`` in their ``setUp()`` methods.

    >>> class Layer1(Layer):
    ...     def setUp(self):
    ...         self['foo'] = 1
    >>> LAYER1 = Layer1()

    >>> class Layer2(Layer):
    ...     __bases__ = (LAYER1,)
    ...     def setUp(self):
    ...         self['foo'] = 2
    >>> LAYER2 = Layer2()

    >>> class Layer3(Layer):
    ...     def setUp(self):
    ...         self['foo'] = 3
    >>> LAYER3 = Layer3()

    >>> class Layer4(Layer):
    ...     __bases__ = (LAYER2, LAYER3,)
    ...     def setUp(self):
    ...         self['foo'] = 4
    >>> LAYER4 = Layer4()

If a test was using ``LAYER4``, the test runner would call each setup step in
turn, starting with the "deepest" layer. We'll simulate that here, so that
each of the resources is created.

    >>> LAYER1.setUp()
    >>> LAYER2.setUp()
    >>> LAYER3.setUp()
    >>> LAYER4.setUp()

Each layer maintains its own resources.

    >>> LAYER1._resources
    {'foo': 1}
    
    >>> LAYER2._resources
    {'foo': 2}
    
    >>> LAYER3._resources
    {'foo': 3}
    
    >>> LAYER4._resources
    {'foo': 4}

The layers are ordered in a known "resource resolution order", which is used
to determine in which order the layers shadow one another. This is based on
the same algorithm as Python's method resolution order.

    >>> LAYER4.resourceResolutionOrder() # doctest: +NORMALIZE_WHITESPACE
    (<Layer '__builtin__.Layer4'>,
     <Layer '__builtin__.Layer2'>,
     <Layer '__builtin__.Layer1'>,
     <Layer '__builtin__.Layer3'>)

When fetching and item from a layer, it will be obtained according to the
resource resolution order.

    >>> LAYER4['foo']
    4

This is not terribly interesting, since ``LAYER4`` has the resource ``'foo'``
set directly. Let's delete that and see where it goes next.

    >>> del LAYER4['foo']
    >>> LAYER4['foo']
    2

We can continue up the chain:

    >>> del LAYER2['foo']
    >>> LAYER4['foo']
    1

    >>> del LAYER1['foo']
    >>> LAYER4['foo']
    3

Once we've deleted the last key, we'll get a ``KeyError``:

    >>> del LAYER3['foo']
    >>> LAYER4['foo']
    Traceback (most recent call last):
    ...
    KeyError: 'foo'

To guard against this, we can use the ``get()`` method.

    >>> LAYER4.get('foo', -1)
    -1

To illustrate that this indeed works, let's set the resource back on one
of the bases.

    >>> LAYER3['foo'] = 10
    >>> LAYER4.get('foo', -1)
    10

Doctest layer helper
====================

The ``doctest`` module is not aware of ``zope.testing``'s layers concept.
Therefore, the syntax for creating a doctest with a layer and adding it to
a test suite is somewhat contrived: the test suite has to be created first, 
and then the layer attribute set on it:

    >>> class DoctestLayer(Layer):
    ...     pass
    >>> DOCTEST_LAYER = DoctestLayer()

    >>> import unittest2 as unittest
    >>> import doctest

    >>> def test_suite():
    ...     suite = unittest.TestSuite()
    ...     layerDoctest = doctest.DocFileSuite('layer.txt', package='plone.testing')
    ...     layerDoctest.layer = DOCTEST_LAYER
    ...     suite.addTest(layerDoctest)
    ...     return suite

    >>> suite = test_suite()
    >>> tests = list(suite)
    >>> len(tests)
    1
    >>> tests[0].layer is DOCTEST_LAYER
    True


To make this a little easier - especially when setting up multiple tests -
a helper function called ``layered`` is provided:

    >>> from plone.testing import layered

    >>> def test_suite():
    ...     suite = unittest.TestSuite()
    ...     suite.addTests([
    ...         layered(doctest.DocFileSuite('layer.txt', package='plone.testing'), layer=DOCTEST_LAYER),
    ...         # repeat with more suites if necessary
    ...     ])
    ...     return suite

This does the same as the sample above.

    >>> suite = test_suite()
    >>> tests = list(suite)
    >>> len(tests)
    1
    >>> tests[0].layer is DOCTEST_LAYER
    True
